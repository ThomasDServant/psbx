---
title: "PACQUET PRACMA"
output: html_document
author: "Victor Garcia" 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction 

Ce package fournit des impl√©mentations R de fonctions plus avanc√©es en analyse num√©rique, avec une vue sp√©ciale sur l'optimisation et les routines de s√©ries chronologiques. Utilise les noms de fonction Matlab / Octave le cas √©ch√©ant pour simplifier le portage.

Certaines de ces impl√©mentations sont le r√©sultat de cours sur le calcul scientifique (`` Wissenschaftliches Rechnen '') et sont principalement destin√©es √† d√©montrer comment impl√©menter certains algorithmes en R / S. D'autres sont des impl√©mentations d'algorithmes trouv√©s dans les manuels.

## D√©tails :

Le package comprend des fonctions de tous les domaines de l'analyse num√©rique, par exemple:


Recherche de racines et minimisation des fonctions univari√©es, par exemple Newton-Raphson, Brent-Dekker, Fibonacci ou recherche de ¬´nombre d'or¬ª. 
<br> Manipulation des polyn√¥mes, y compris les racines et l'ajustement polynomial,par exemple les m√©thodes de Laguerre et Muller.
<br> Interpolation et approximation de fonction,interpolation de Lagrange barycentrique , interpolation Pade et rationnelle, Chebyshev ou approximation trigonom√©trique.
<br> Certaines fonctions sp√©ciales,par exemple les int√©grales de Fresnel, le Zeta de Riemann ou la fonction Gamma complexe, et le W de Lambert calcul√© de mani√®re it√©rative par la m√©thode de Newton.
<br> Matrices sp√©ciales, par exemple Hankel, Rosser, Wilkinson
<br> Diff√©renciation et int√©gration num√©riques,approche de Richardson et d√©riv√©s de `` pas complexes '', int√©gration adaptative de Simpson et Lobatto et quadrature adaptative de Gauss-Kronrod.
<br> Solveurs pour les √©quations et syst√®mes diff√©rentiels ordinaires,Euler-Heun, Runge-Kutta classique, ode23, ou m√©thode pr√©dicteur-correcteur comme Adams-Bashford-Moulton.
<br> Certaines fonctions de la th√©orie des nombres,telles que les nombres premiers et la factorisation des nombres premiers, l'algorithme euclidien √©tendu.
<br> Routines de tri, par exemple quickstep r√©cursif.
<br> Plusieurs fonctions pour la manipulation de cha√Ænes et la recherche r√©guli√®re, toutes envelopp√©es et nomm√©es de la m√™me mani√®re que leurs analogues Matlab.

## Les Buts : 
Il sert trois objectifs principaux:

<br> Collecter des scripts R qui peuvent √™tre d√©montr√©s dans des cours sur l'analyse num√©rique ou le calcul scientifique en utilisant R / S comme langage de programmation choisi.
<br> Emballage des fonctions avec les noms Matlab appropri√©s pour simplifier le portage des programmes de Matlab ou Octave vers R.
<br> Fournir un environnement dans lequel R peut √™tre utilis√© comme un syst√®me de calcul num√©rique √† part enti√®re.





## La fonction : barylag2d

Interpolation de Lagrange barycentrique bidimensionnelle.

Les nombres ai s'appellent les points d'interpolations ou encore noeuds d'interpolations.
<br> Lorsque fi = f(ai), la fonction f est la fonction interpolÈe.

On dit aussi que les valeurs f(ai) sont les valeurs interpolÈes L'unique polynÙme p ??? Pd vÈrifiant p(ai) = f(ai) (i = 0,1,...,d) s'appelle alors le polynÙme
d'interpolation de Lagrange de f aux points ai
. Il est notÈ L[a0,...,ad; f ] ou
bien L[A; f ].
Cette derniËre notation est parfaitement valable car le polynÙme d'interpolation de Lagrange dÈpend uniquement de l'ensemble des points et non de la
maniËre dont les points sont ordonnÈs. Une maniËre un peu sophistiquÈe de traduire cette propriÈtÈ est la suivante : si ?? est une permutation??? quelconque des
indices 0,1,...,d alors L[a0,...,ad; f ] = L[a??(0)
,...,a??(d)
; f ].
Les polynÙmes ???i s'appellent les polynÙmes fondamentaux de Lagrange.
En utilisant le symbole ??? qui est l'Èquivalent pour le produit de ce que ??? est
??? Une permutation des indices 0,1,...,d est une bijection de l'ensemble{0,1,...,d} dans luimÍme.
[TH 1] jpc / ALG
ß 1. INTRODUCTION ¿ L'INTERPOLATION POLYNOMIALE 5
pour la somme, on a la formule suivante qui est une variante compacte de (1.9).
???i(x) =
d
???
j=0, j6=i
x???aj
ai ???aj
. (1.10)
Avec ces nouvelles notations, l'expression (1.8) devient
L[a0,...,ad; f ](x) =
d
???
i=0
f(ai)
d
???
j=0, j6=i
x???aj
ai ???aj
. (1.11)
Cette expression de L[A; f ] est connue sous le nom de formule d'interpolation
de Lagrange.
d) PropriÈtÈs algÈbriques et linÈaritÈ
Il est essentiel de retenir l'Èquivalence suivante
p ??? Pd
p(ai) = f(ai) i = 0,...,d
æ
??? p = L[a0,...,ad; f ] (1.12)
En particulier,
si p ??? Pd alors L[a0,...,ad; p] = p.
Il faut prendre garde que cette propriÈtÈ n'est valable que lorsque le degrÈ de p
est infÈrieur o˘ Ègal ‡ d.
Cette relation implique des propriÈtÈs algÈbriques intÈressantes sur les polynÙmes ???i
. Par exemple, en utilisant que, quel que soit le nombre de points, le
polynÙme constant Ègal ‡ 1 est son propre polynome d'interpolation on a
d
???
i=0
???i = 1. 

```[r]
a_ {n + 1} = (a_n + b_n) / 2 et b_ {n + 1} = ‚àö (a_n b_n).

```

Lorsqu'elle est utilis√©e pour des nombres n√©gatifs ou complexes, la fonction racine carr√©e complexe est appliqu√©e.

```{r}
library(pracma)
agmean(a,b)
#avec a et b deux vecteurs de nombres r√©els ou complexes de meme longueur ( ou scalaire)

```

## Exemples : 
```{r}
##  Example from R-help
xn <- c(4.05, 4.10, 4.15, 4.20, 4.25, 4.30, 4.35)
yn <- c(60.0, 67.5, 75.0, 82.5, 90.0)
foo <- matrix(c(
        -137.8379, -158.8240, -165.4389, -166.4026, -166.2593,
        -152.1720, -167.3145, -171.1368, -170.9200, -170.4605,
        -162.2264, -172.5862, -174.1460, -172.9923, -172.2861,
        -168.7746, -175.2218, -174.9667, -173.0803, -172.1853,
        -172.4453, -175.7163, -174.0223, -171.5739, -170.5384,
        -173.7736, -174.4891, -171.6713, -168.8025, -167.6662,
        -173.2124, -171.8940, -168.2149, -165.0431, -163.8390),
            nrow = 7, ncol = 5, byrow = TRUE)
xf <- c(4.075, 4.1)
yf <- c(63.75, 67.25)
barylag2d(foo, xn, yn, xf, yf)
#  -156.7964 -163.1753
#  -161.7495 -167.0424

# Find the minimum of the underlying function
bar <- function(xy) barylag2d(foo, xn, yn, xy[1], xy[2])
optim(c(4.25, 67.5), bar)  # "Nelder-Mead"
# $par
# 4.230547 68.522747
# $value
# -175.7959
```




























